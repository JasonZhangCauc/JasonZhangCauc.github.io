<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test0923]]></title>
    <url>%2F2018%2F09%2F23%2Ftest0923%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>categorie</category>
      </categories>
      <tags>
        <tag>tags</tag>
        <tag>tags2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F22%2Fhello-world%20-%20%E5%89%AF%E6%9C%AC%20(6)%2F</url>
    <content type="text"><![CDATA[Hello! Friends! 1234567891011121314151617181920212223242526272829303132&lt;head&gt; ... &lt;link rel="stylesheet" type="text/css" href="http://github.jmzhang.top/css/EnlighterJS.min.css" /&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/MooTools.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/EnlighterJS.min.js" &gt;&lt;/script&gt; &lt;meta name="EnlighterJS" content="Advanced javascript based syntax highlighting" data-indent="4" data-selector-block="pre" data-selector-inline="code.special" /&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;pre data-enlighter-language="java" &gt; public class duiliecz &#123; // ���в����� /** * @param args */ private int i = 0; // ���г� private duilie top = new duilie(""); // ����ͷ private duilie end = new duilie(""); // ����β public void add(String s) &#123; // ��Ӷ��� duilie m = new duilie(s); if (i != 0) &#123; m.setS(top.getS()); top.setS(m); &#125; else &#123; top.setS(m); end.setS(m); &#125; i++; &#125; &lt;/pre&gt; ...&lt;/body&gt; Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F22%2Fhello-world%20-%20%E5%89%AF%E6%9C%AC%20(5)%2F</url>
    <content type="text"><![CDATA[Hello! Friends! 1234567891011121314151617181920212223242526272829303132&lt;head&gt; ... &lt;link rel="stylesheet" type="text/css" href="http://github.jmzhang.top/css/EnlighterJS.min.css" /&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/MooTools.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/EnlighterJS.min.js" &gt;&lt;/script&gt; &lt;meta name="EnlighterJS" content="Advanced javascript based syntax highlighting" data-indent="4" data-selector-block="pre" data-selector-inline="code.special" /&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;pre data-enlighter-language="java" &gt; public class duiliecz &#123; // ���в����� /** * @param args */ private int i = 0; // ���г� private duilie top = new duilie(""); // ����ͷ private duilie end = new duilie(""); // ����β public void add(String s) &#123; // ��Ӷ��� duilie m = new duilie(s); if (i != 0) &#123; m.setS(top.getS()); top.setS(m); &#125; else &#123; top.setS(m); end.setS(m); &#125; i++; &#125; &lt;/pre&gt; ...&lt;/body&gt; Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F22%2Fhello-world%20-%20%E5%89%AF%E6%9C%AC%20(4)%2F</url>
    <content type="text"><![CDATA[Hello! Friends! 1234567891011121314151617181920212223242526272829303132&lt;head&gt; ... &lt;link rel="stylesheet" type="text/css" href="http://github.jmzhang.top/css/EnlighterJS.min.css" /&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/MooTools.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/EnlighterJS.min.js" &gt;&lt;/script&gt; &lt;meta name="EnlighterJS" content="Advanced javascript based syntax highlighting" data-indent="4" data-selector-block="pre" data-selector-inline="code.special" /&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;pre data-enlighter-language="java" &gt; public class duiliecz &#123; // ���в����� /** * @param args */ private int i = 0; // ���г� private duilie top = new duilie(""); // ����ͷ private duilie end = new duilie(""); // ����β public void add(String s) &#123; // ��Ӷ��� duilie m = new duilie(s); if (i != 0) &#123; m.setS(top.getS()); top.setS(m); &#125; else &#123; top.setS(m); end.setS(m); &#125; i++; &#125; &lt;/pre&gt; ...&lt;/body&gt; Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F22%2Fhello-world%20-%20%E5%89%AF%E6%9C%AC%20(3)%2F</url>
    <content type="text"><![CDATA[Hello! Friends! 1234567891011121314151617181920212223242526272829303132&lt;head&gt; ... &lt;link rel="stylesheet" type="text/css" href="http://github.jmzhang.top/css/EnlighterJS.min.css" /&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/MooTools.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/EnlighterJS.min.js" &gt;&lt;/script&gt; &lt;meta name="EnlighterJS" content="Advanced javascript based syntax highlighting" data-indent="4" data-selector-block="pre" data-selector-inline="code.special" /&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;pre data-enlighter-language="java" &gt; public class duiliecz &#123; // ���в����� /** * @param args */ private int i = 0; // ���г� private duilie top = new duilie(""); // ����ͷ private duilie end = new duilie(""); // ����β public void add(String s) &#123; // ��Ӷ��� duilie m = new duilie(s); if (i != 0) &#123; m.setS(top.getS()); top.setS(m); &#125; else &#123; top.setS(m); end.setS(m); &#125; i++; &#125; &lt;/pre&gt; ...&lt;/body&gt; Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F22%2Fhello-world%20-%20%E5%89%AF%E6%9C%AC%20(2)%2F</url>
    <content type="text"><![CDATA[Hello! Friends! 1234567891011121314151617181920212223242526272829303132&lt;head&gt; ... &lt;link rel="stylesheet" type="text/css" href="http://github.jmzhang.top/css/EnlighterJS.min.css" /&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/MooTools.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/EnlighterJS.min.js" &gt;&lt;/script&gt; &lt;meta name="EnlighterJS" content="Advanced javascript based syntax highlighting" data-indent="4" data-selector-block="pre" data-selector-inline="code.special" /&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;pre data-enlighter-language="java" &gt; public class duiliecz &#123; // ���в����� /** * @param args */ private int i = 0; // ���г� private duilie top = new duilie(""); // ����ͷ private duilie end = new duilie(""); // ����β public void add(String s) &#123; // ��Ӷ��� duilie m = new duilie(s); if (i != 0) &#123; m.setS(top.getS()); top.setS(m); &#125; else &#123; top.setS(m); end.setS(m); &#125; i++; &#125; &lt;/pre&gt; ...&lt;/body&gt; Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F22%2Fhello-world%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Hello! Friends! 1234567891011121314151617181920212223242526272829303132&lt;head&gt; ... &lt;link rel="stylesheet" type="text/css" href="http://github.jmzhang.top/css/EnlighterJS.min.css" /&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/MooTools.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/EnlighterJS.min.js" &gt;&lt;/script&gt; &lt;meta name="EnlighterJS" content="Advanced javascript based syntax highlighting" data-indent="4" data-selector-block="pre" data-selector-inline="code.special" /&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;pre data-enlighter-language="java" &gt; public class duiliecz &#123; // ���в����� /** * @param args */ private int i = 0; // ���г� private duilie top = new duilie(""); // ����ͷ private duilie end = new duilie(""); // ����β public void add(String s) &#123; // ��Ӷ��� duilie m = new duilie(s); if (i != 0) &#123; m.setS(top.getS()); top.setS(m); &#125; else &#123; top.setS(m); end.setS(m); &#125; i++; &#125; &lt;/pre&gt; ...&lt;/body&gt; Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的八种排序算法Java代码实现]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Algorithm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323package algorithm;import java.util.Arrays;public class EightAlgorithm &#123; /** * * 常用的八种排序算法Java代码实现 * 时间：2018-9-5-下午9:14:30 * 邮件：hasp_Jason@163.com * @exception * *辅助记忆* * 时间复杂度记忆- * 冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O（n2）（一遍找元素O(n)，一遍找位置O(n)） * 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)） * 稳定性记忆-“快选希堆”（非稳定：快牺牲稳定性） * 排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。 */ public static void main(String[] args) &#123; int []array=&#123;23,56,8,45,2,95,11,12,17,10,11&#125;; System.out.println("length: "+array.length); insertSort(array); //1.直接插入 //sheelSort(array); //2.希尔排序 //selectSort(array); //3.简单选择排序 //heapSort(array); //4.堆排序 //bubbleSort(array); //5.冒泡排序 //quickSort(array, 0, array.length-1);//6.快速排序 //mergeSort(array); //7.归并排序 //sort(array,10); //8.基数排序 System.out.println(Arrays.toString(array)); &#125; /** * 1.直接插入 经常碰到这样一类排序问题：把新的数据插入到已经排好的数据列中。 * 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 * O（n^2） O（n^2） O（1） 是 * 将第一个数和第二个数排序，然后构成一个有序序列 * 将第三个数插入进去，构成一个新的有序序列。 * 对第四个数、第五个数……直到最后一个数，重复第二步。 * ***如何写成代码： * 1.首先设定插入次数，即循环次数，for(int i=1;i&lt;length;i++)，1个数的那次不用插入。 * 2.设定插入数和得到已经排好序列的最后一个数的位数。insertNum和j=i-1。 * 3.从最后一个数开始向前循环，如果插入数小于当前数，就将当前数向后移动一位。 * 4.将当前数放置到空着的位置，即j+1。 */ public static void insertSort(int[] a) &#123; int insertNum; // 要插入的数 for (int i = 1; i &lt; a.length; i++) &#123; insertNum = a[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; a[j] &gt; insertNum) &#123;// 将大于insertNum的数向后移动一格 a[j + 1] = a[j]; j--; &#125; a[j + 1] = insertNum; &#125; &#125; /** * 2.希尔排序 对于直接插入排序问题，数据量巨大时。 * 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 * O(nlogn) O（n^s） O（1） 不是 * 将数的个数设为n，取奇数k=n/2，将下标差值为k的数分为一组，构成有序序列。 * 再取k=k/2 ，将下标差值为k的数分为一组，构成有序序列。 * 重复第二步，直到k=1执行简单插入排序。 * ***如何写成代码： * 1.首先确定分的组数。 * 2.然后对组中元素进行插入排序。 * 3.然后将length/2，重复1,2步，直到length=0为止。 */ public static void sheelSort(int[] a) &#123; int length = a.length; while (length != 0) &#123; length = length / 2; System.out.println("length变化： " + length); for (int x = 0; x &lt; length; x++) &#123; // 分组个数 for (int i = x + length; i &lt; a.length; i += length) &#123; int j = i - length; // j为有序序列最后一位的位数 int insertNum = a[i]; // 要插入的元素 for (; j &gt;= 0 &amp;&amp; insertNum &lt; a[j]; j -= length) &#123; a[j + length] = a[j]; // 向后移动length位 &#125; a[j + length] = insertNum; &#125; &#125; &#125; &#125; /** * 3.简单选择排序 常用于取序列中最大最小的几个数时。 * 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 * O（n^2） O（n^2） O（1） 不是 * (如果每次比较都交换，那么就是交换排序；如果每次比较完一个循环再交换，就是简单选择排序。) * 遍历整个序列，将最小的数放在最前面。 * 遍历剩下的序列，将最小的数放在最前面。 * 重复第二步，直到只剩下一个数。 * ***如何写成代码： * 1.首先确定循环次数，并且记住当前数字和当前位置。 * 2.将当前位置后面所有的数与当前数字进行对比，小数赋值给key，并记住小数的位置。 * 3.比对完成后，将最小的值与第一个数的值交换。 * 4.重复2、3步。 */ public static void selectSort(int[] a) &#123; int length = a.length; for (int i = 0; i &lt; length; i++) &#123; // 循环次数 int key = a[i]; int position = i; for (int j = i + 1; j &lt; length; j++) &#123; // 选出最小值和位置 if (a[j] &lt; key) &#123; key = a[j]; position = j; &#125; &#125; a[position] = a[i]; // 交换位置 a[i] = key; &#125; &#125; /** * 4.堆排序 对简单选择排序的优化。 * 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 * O(nlogn) O(nlogn) O（1） 不是 * 将序列构建成大顶堆。 * 将根节点与最后一个节点交换，然后断开最后一个节点。 * 重复第一、二步，直到所有节点断开。 */ public static void heapSort(int[] a) &#123; System.out.println("开始排序"); int arrayLength = a.length; // 循环建堆 for (int i = 0; i &lt; arrayLength - 1; i++) &#123; // 建堆 buildMaxHeap(a, arrayLength - 1 - i); // 交换堆顶和最后一个元素 swap(a, 0, arrayLength - 1 - i); System.out.println(Arrays.toString(a)); &#125; &#125; private static void swap(int[] data, int i, int j) &#123; int tmp = data[i]; data[i] = data[j]; data[j] = tmp; &#125; // 对data数组从0到lastIndex建大顶堆 private static void buildMaxHeap(int[] data, int lastIndex) &#123; // 从lastIndex处节点（最后一个节点）的父节点开始 for (int i = (lastIndex - 1) / 2; i &gt;= 0; i--) &#123; // k保存正在判断的节点 int k = i; // 如果当前k节点的子节点存在 while (k * 2 + 1 &lt;= lastIndex) &#123; // k节点的左子节点的索引 int biggerIndex = 2 * k + 1; // 如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if (biggerIndex &lt; lastIndex) &#123; // 若果右子节点的值较大 if (data[biggerIndex] &lt; data[biggerIndex + 1]) &#123; // biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; // 如果k节点的值小于其较大的子节点的值 if (data[k] &lt; data[biggerIndex]) &#123; // 交换他们 swap(data, k, biggerIndex); // 将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k = biggerIndex; &#125; else &#123; break; &#125; &#125; &#125; &#125; /** * 5.冒泡排序 一般不用。 * 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 * O（n^2） O（n^2） O（1） 是 * 将序列中所有元素两两比较，将最大的放在最后面。 * 将剩余序列中所有元素两两比较，将最大的放在最后面。 * 重复第二步，直到只剩下一个数。 * ***如何写成代码： * 1.设置循环次数。 * 2.设置开始比较的位数，和结束的位数。 * 3.两两比较，将最小的放到前面去。 * 4.重复2、3步，直到循环次数完毕。 * */ public static void bubbleSort(int[] a) &#123; int length = a.length; int temp; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; j &lt; length - i - 1; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; &#125; /** * 6.快速排序 要求时间最快时。 * 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 * O(nlogn) O（n^2） O（logn） 不是 * 选择第一个数为p，小于p的数放在左边，大于p的数放在右边。 * 递归的将p左边和右边的数都按照第一步进行，直到不能递归。 */ public static void quickSort(int[] numbers, int start, int end) &#123; if (start &lt; end) &#123; int base = numbers[start];// 选定的基准值 int temp; int i = start, j = end; do &#123; while ((numbers[i] &lt; base) &amp;&amp; (i &lt; end)) i++; while ((numbers[j] &gt; base) &amp;&amp; (j &gt; start)) j--; if (i &lt;= j) &#123; temp = numbers[i]; numbers[i] = numbers[j]; numbers[j] = temp; i++; j--; &#125; &#125; while (i &lt;= j); if (start &lt; j) quickSort(numbers, start, j); if (end &gt; i) quickSort(numbers, i, end); &#125; &#125; /** * 7.归并排序 速度仅次于快排，内存少的时候使用，可以进行并行计算的时候使用。 * 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 * O(nlogn) O(nlogn) O（n） 是 * 选择相邻两个数组成一个有序序列。 * 选择相邻的两个有序序列组成一个有序序列。 * 重复第二步，直到全部组成一个有序序列。 */ public static void mergeSort(int[] arr) &#123; int[] temp = new int[arr.length];// 在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间 mergeSort(arr, 0, arr.length - 1, temp); &#125; private static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; mergeSort(arr, left, mid, temp);// 左边归并排序，使得左子序列有序 mergeSort(arr, mid + 1, right, temp);// 右边归并排序，使得右子序列有序 merge(arr, left, mid, right, temp);// 将两个有序子数组合并操作 &#125; &#125; private static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left;// 左序列指针 int j = mid + 1;// 右序列指针 int t = 0;// 临时数组指针 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt;= arr[j]) &#123; temp[t++] = arr[i++]; &#125; else &#123; temp[t++] = arr[j++]; &#125; &#125; while (i &lt;= mid) &#123;// 将左边剩余元素填充进temp中 temp[t++] = arr[i++]; &#125; while (j &lt;= right) &#123;// 将右序列剩余元素填充进temp中 temp[t++] = arr[j++]; &#125; t = 0; // 将temp中的元素全部拷贝到原数组中 while (left &lt;= right) &#123; arr[left++] = temp[t++]; &#125; &#125; /** * 8.基数排序 用于大量数，很长的数进行排序时。 * 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 * O(N∗M) O(N∗M) O(M) 是 * 将所有的数的个位数取出，按照个位数进行排序，构成一个序列。 * 将新构成的所有的数的十位数取出，按照十位数进行排序，构成一个序列。 */ public static void sort(int[] number, int d) &#123; int k = 0; int n = 1; int m = 1; int[][] temp = new int[number.length][number.length]; int[] order = new int[number.length]; while (m &lt;= d) &#123; for (int i = 0; i &lt; number.length; i++) &#123; int lsd = ((number[i] / n) % 10); temp[lsd][order[lsd]] = number[i]; order[lsd]++; &#125; for (int i = 0; i &lt; d; i++) &#123; if (order[i] != 0) for (int j = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0; &#125; n *= 10; k = 0; m++; &#125; &#125; &#125;]]></content>
      <categories>
        <category>java</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java关键字volatile]]></title>
    <url>%2F2018%2F09%2F05%2Fjava%E5%85%B3%E9%94%AE%E5%AD%97volatile%2F</url>
    <content type="text"><![CDATA[Volatile中文译为【易变的、不稳定的】，它被用来修饰那些被不同的线程访问和修改的变量。 学习volatile我们首先要来看一下Java内存模型(即Java Memory Model，简称JMM)。 Java内存模型中规定了所有的变量都存储在主内存中，每条java线程各自拥有自己的工作内存，线程的工作内存中保存了该线程使用到的主内存中的共享变量的副本，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如上图所示。 Volatile 修饰的变量即为主内存中的共享变量，当一个共享变量被volatile修饰后，那么当这个变量在工作内存发生了变化后，必须要马上写到主内存中，而线程读取到是volatile修饰的变量时，必须去主内存中去获取最新的值，而不是读工作内存中主内存的副本，这就有效的保证了线程之间变量的可见性。 这就是volatile的第一个特性，内存可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 我们来看一段代码： 123456789101112131415161718192021222324252627282930public class VolatileTest01 &#123; // a是一个验证结果的变量 private static int a=0; private static int b=0; static boolean stop=false;public static void main(String[] args) throws InterruptedException &#123; ThreadA threadA=new ThreadA(); ThreadB threadB=new ThreadB(); threadA.start(); threadB.start(); &#125; //线程A static class ThreadA extends Thread&#123; public void run()&#123; while(!stop) &#123; System.out.println(a); a++; &#125; &#125; &#125; //线程B static class ThreadB extends Thread&#123; public void run()&#123; b=666; stop=true; b=666; &#125; &#125;&#125; 我们会发现，当线程B执行语句stop=true;后，会中断线程A的执行。但有没有可能A出现死循环呢？答案是有的，即当线程B更改了stop变量之后还没来得及将stop变量写入主存当中，线程B就转去做其他事了，这时线程A由于不知道线程B对stop变量的更改，因此会一直循环下去，虽然这种情况发生即概论很低，但是一旦发生了将造成很严重的后果。 使用volatile关键字后我们便可以解决这个问题，但是这样就可以保证线程安全了吗？答案是不能，我们来看一下下面这段代码： 1234567891011121314151617181920212223242526public class VolatileTest05 &#123; public volatile static int num=0; public static void main(String[] args) &#123; for(int i=0;i&lt;10;i++)&#123; new Thread( new Runnable() &#123; public void run() &#123; try &#123; Thread.sleep(1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; for(int j=0;j&lt;100;j++)&#123; num++; &#125; &#125; &#125;).start(); &#125; try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("num=:"+num); &#125;&#125; 通过上面的代码我们创建10个线程，每个线程中让num自增100次。执行后你会发现结果并不是我们想的1000，而是小于1000.这是为什么呢？因为volatile并不能让一个操作变成原子操作。Num++本身并不是原子操作，转换为字节码是这样的： getstatic //读取静态变量（num） iconst_1 //定义常量1 iadd //num增加1 putstatic //把num结果同步到主内存 虽然每次get后得到的都是最新变量值，但是进行idd的时候，由于非原子性操作，其他线程可能已经将num++执行了很多次，此时这个线程更新出的num便已经不是我们所期望得到的num值。 JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，为了在不改变程序执行结果的前提下，优化程序的运行效率会对现有的指令顺序进行重新排序。 Volatile第二个特性即是可以防止指令重排序。 我们来看下面这个例子： boolean contextReady = false; 在线程A中执行: context = loadContext();//初始化context contextReady = true; 在线程B中执行: while( ! contextReady ){ sleep(200); } doAfterContextReady (context); 但如果一旦线程A中的指令重排序，会变成这样的执行顺序： boolean contextReady = false; 线程A: contextReady = true; context = loadContext();//初始化context 线程B: while( ! contextReady ){ sleep(200); } doAfterContextReady (context); 我们发现context并没有进行初始化线程B跳出循环等待后便执行了doAfterContextReady(context)方法，程序报错。 此时我们可以给contextReady 增加volatile方法，以此解决关于contextReady的指令重排序的问题。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手四次挥手]]></title>
    <url>%2F2018%2F09%2F04%2FTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[由于网上关于TCP三次握手四次挥手的内容已经很丰富，所以我们今天趣味讲解一下TCP三次握手和四次挥手。 三次握手： 首先先上图： ![TCP三次握手] 由于我给客户端和服务端都上了色，所以暂且就叫他们小蓝（Client）和小绿（Server）就好了。 由于一次意外，两人都双目失明，看不见了。他们只能通过声音辨认对方。 小蓝首先叫了一声小绿（syn） 小绿听见听见小蓝在叫自己，便答应了一声自己在（ack），但小绿怕小蓝叫的是其他的小绿，便问小蓝是在叫自己吗（syn），小蓝听到后知道了是小绿，便进入（established）状态。 最后小蓝也答应了一声是自己（ack），小绿听到后进入（established）状态。 这其中还有两个中间态：syn_sent和syn_rcvd，这两个状态叫【半打开】状态，也就是两人呼唤对方。Syn_sent是客户端的半打开状态，sun_rcvd是服务端的半打开状态。 Syn_sent : syn package has been sent Syn_rcvd : syn package has been received 官方语言: TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态； TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号seq=x ，此时，TCP客户端进程进入了SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。 TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。 TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 四次挥手: ![TCP四次挥手] 两人离别的时候， 小蓝说“我要走了”（FIN） 小绿回应“那好吧”（ACK） 此时小绿说了一些话，但发现小蓝真的不说话了，就说“我也走了”（FIN） 小蓝回应了一句“好的”（ACK） 官方语言： 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 状态time_wait是一个非常特殊的状态，它是主动关闭的一方在回复完对方后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。 这个后果就是持续4分钟的time_wait状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。 它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。 同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。 4分钟就是2个MSL，每个MSL是2分钟。MSL就是maximium segmentlifetime——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL呢？ 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。 第二，防止“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 最后一个问题，为什么建立连接是三次握手，关闭连接确是四次挥手呢？ 建立连接的时候，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从fin_wait_1状态直接进入到time_wait状态，跳过了fin_wait_2状态。 扩展：TCP数据传输 数据传输过程即是小蓝和小绿对话的过程。 只不过两人隔着河，且都看不见，所以当一方说话后（data）需要对方听到了回应一声（ACK）。 如果小蓝喊了一句，半天没听到小绿回复，小蓝就认为自己的话被大风吹走了，小绿没听见，所以需要重新喊话，这就是【tcp重传】。 也有可能是小绿听到了小蓝的话，但是小绿向小蓝的回复被大风吹走了，以至于小蓝没听见小绿的回复。小蓝并不能判断究竟是自己的话被大风吹走了还是小绿的回复被大风吹走了，小蓝也不用管，重传一下就是。 既然会重传，小绿就有可能同一句话听见了两次，这就是【去重】。【重传】和【去重】工作操作系统的网络内核模块都已经帮我们处理好了。 小蓝可以向小绿喊话，同样小绿也可以向小蓝喊话，因为tcp链接是「双工的」，双方都可以主动发起数据传输。不过无论是哪方喊话，都需要收到对方的确认才能认为对方收到了自己的喊话。 小蓝可能是个八卦，一说连说了八句话，这时候小绿可以不用一句一句回复，而是连续听了这八句话之后，一起向对方回复说前面你说的八句话我都听见了，这就是批量ack。但是小蓝也不能一次性说了太多话，小绿的脑子短时间可能无法消化太多，两人之间需要有协商好的合适的发送和接受速率，这个就是【TCP窗口大小】。 网络环境的数据交互同人类之间的对话还要复杂一些，它存在数据包乱序的现象。同一个来源发出来的不同数据包在「网际路由」上可能会走过不同的路径，最终达到同一个地方时，顺序就不一样了。操作系统的网络内核模块会负责对数据包进行排序，到用户层时顺序就已经完全一致了。 好了，今天就介绍到这里了，说的比较简单，深的等以后写，每天进步一点点，希望世界充满正能量！]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客]]></title>
    <url>%2F2018%2F09%2F03%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[博主我用过很多云服务器、云主机搭建个人博客网站，但没用过github的page页，想尝试下，搞了一会就搭建完成了，总的来说很顺利，在这里分享给大家。 安装Hexo安装node.js node.js官方下载地址 从上面的链接下载node.js，并安装。 下载LTS那个即可 申请Github账号 Github注册页面 输入用户名，Email，密码，注册账号。比如我的用户名是：JasonZhangCauc 创建博客仓库 注意，仓库名应该为：用户名.github.io。比如，我的仓库名是：JasonZhangCauc.github.io。 安装git git下载地址 下载git安装文件，双击执行安装。 配置ssh 打开git bash终端。 设置user.name和user.email。 git config –global user.name “你的GitHub用户名” git config –global user.email “你的GitHub注册邮箱” 生成ssh密匙 ssh-keygen -t rsa -C “你的GitHub注册邮箱” 此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub。 将公匙添加到github上 详细教程自行baidu。 用户头像→Settings→SSH and GPG keys→New SSHkey→将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSHkey(添加SSH)按钮。 安装hexo 执行以下命令安装hexo。 # 安装hexo npm install hexo-cli g# 初始化博客文件夹 hexo init blog# 切换到该路径cd blog# 安装hexo的扩展插件 npm install# 安装其它插件 npm install hexo-server –save npm install hexo-admin –save npm install hexo-generator-archive –save npm install hexo-generator-feed –save npm install hexo-generator-search –save npm install hexo-generator-tag –save npm install hexo-deployer-git –save npm install hexo-generator-sitemap –save 初探hexo 第一次使用hexo，在本地创建服务器使用。 # 生成静态页面 hexo generate# 开启本地服务器 hexo s 打开浏览器，地址栏中输入：http://localhost:4000/,应该可以看见刚刚创建的博客了。 问题：为什么访问http://localhost:4000/，无反应？ 解决方法：可能是由于端口问题引起的。使用Ctrl+C中断本地服务，使用命令hexos -p5000重新开启本地服务，访问http://localhost:5000/可以看到博客页面了。 将hexo博客部署到github上 修改配置文件blog/_config.yml，修改deploy项的内容，如下所示： # Deployment 注释## Docs: https://hexo.io/docs/deployment.htmldeploy: # 类型 type: git # 仓库 repo: git\@github.com:JasonZhangCauc/JasonZhangCauc.github.io.git # 分支 branch: master 注意：type: git中的冒号后面由空格。 注意：将git\@github.com:JasonZhangCauc/JasonZhangCauc.github.io.git中的用户名换成自己的用户名git\@github.com:github_username/github_username.github.io.git。 部署hexo 输入下面的命令将hexo博客部署到github中： # 清空静态页面 hexo clean# 生成静态页面 hexo generate# 部署 hexo deploy 打开网页，输入http://github_username.github.io，打开github上托管的博客。如我的博客地址是：http://JasonZhangCauc.github.io。 hexo命令缩写 hexo支持命令缩写，如下所示。hexo g等价于hexo generate。 hexo g：hexo generate hexo c：hexo clean hexo s：hexo server hexo d：hexo deploy hexo组合命令# 清除、生成、启动 hexo clean &amp;&amp; hexo g -s# 清除、生成、部署 hexo clean &amp;&amp; hexo g -d 附博客维护方法：http://theme-next.iissnan.com/getting-started.html]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello! Friends! 1234567891011121314151617181920212223242526272829303132&lt;head&gt; ... &lt;link rel="stylesheet" type="text/css" href="http://github.jmzhang.top/css/EnlighterJS.min.css" /&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/MooTools.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://github.jmzhang.top/js/EnlighterJS.min.js" &gt;&lt;/script&gt; &lt;meta name="EnlighterJS" content="Advanced javascript based syntax highlighting" data-indent="4" data-selector-block="pre" data-selector-inline="code.special" /&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;pre data-enlighter-language="java" &gt; public class duiliecz &#123; // ���в����� /** * @param args */ private int i = 0; // ���г� private duilie top = new duilie(""); // ����ͷ private duilie end = new duilie(""); // ����β public void add(String s) &#123; // ��Ӷ��� duilie m = new duilie(s); if (i != 0) &#123; m.setS(top.getS()); top.setS(m); &#125; else &#123; top.setS(m); end.setS(m); &#125; i++; &#125; &lt;/pre&gt; ...&lt;/body&gt; Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
